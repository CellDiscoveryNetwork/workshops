---
title: "5 - Multi-Sample Multi-Condition Differential Expression"
author: "CDN team"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format:
  html:
    toc: true
    toc_float: true
    toc-location: left
    toc-depth: 4
    html-math-method: katex
    self-contained-math: true
    embed-resources: true
editor_options: 
  chunk_output_type: console
---

## Introduction

Another way to process single-cell data is to pseudobulk the samples by aggregating the gene counts for cells belonging to each sample. This results in a single count value per gene per sample which is similar to a bulk matrix. Single-cell sparse matrices contain a lot of zeros which create a complicated distribution that makes it less sensitive to recognizing lowly expressed genes. Pseudobulking single-cell data allows scientists to benefit from the statistical rigor of existing bulk DE analysis on their single-cell data.

### Useful Resources

-   [Bioconductor DESeq2 workflow](https://www.bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#interactions) ⭐️
-   [Bioinformagician DESeq2 workflow](https://www.youtube.com/watch?v=04gB2owLKus)
-   [Bioinformagician DESeq2 walk-through](https://www.youtube.com/watch?v=0b24mpzM_5M&t=1204s)

### Key Takeaways

1.  Aggregating gene counts by cell type at the sample level provides a way to determine differentially expressed genes in single-cell data.
2.  Pseudobulking single-cell data allows scientists to benefit from the statistical rigor of pre-existing bulk DE analysis on their single-cell data.
3.  Three

![](pseudobulk_analysis/pseudobulk.png)*Squair, J.W., Gautier, M., Kathe, C. et al. Confronting false discoveries in single-cell differential expression. Nat Commun 12, 5692 (2021). https://doi.org/10.1038/s41467-021-25960-2*\

## Libraries

### Installation

```{r, eval=FALSE}
if (!requireNamespace("tidyverse", quietly = TRUE))
    install.packages('tidyverse')
if (!requireNamespace("Seurat", quietly = TRUE))
    install.packages('Seurat')
if (!requireNamespace("colorBlindness", quietly = TRUE))
    install.packages('colorBlindness')
if (!requireNamespace("RColorBrewer", quietly = TRUE))
    install.packages('RColorBrewer')
# Presto speeds up Wilcoxon tests for marker gene calculation in Seurat
if (!requireNamespace("presto", quietly = TRUE))
    devtools::install_github('immunogenomics/presto')
if (!requireNamespace("DESeq2", quietly = TRUE))
    BiocManager::install('DESeq2')
if (!requireNamespace("org.Hs.eg.db", quietly = TRUE))
    BiocManager::install('org.Hs.eg.db')
if (!requireNamespace("Matrix", quietly = TRUE))
    install.packages('Matrix')
if (!requireNamespace("tictoc", quietly = TRUE))
    install.packages('tictoc')
if (!requireNamespace("AnnotationDbi", quietly = TRUE))
    install.packages('AnnotationDbi')
if (!requireNamespace("DT", quietly = TRUE))
    install.packages('DT')
if (!requireNamespace("EnhancedVolcano", quietly = TRUE))
    BiocManager::install('EnhancedVolcano')
if (!requireNamespace("sparseMatrixStats", quietly = TRUE))
    BiocManager::install('sparseMatrixStats')

```

### Load Libraries

```{r}
suppressPackageStartupMessages({
  library(presto)
  library(DESeq2)
  library(tidyverse)
  library(Seurat)
  library(colorBlindness)
  library(RColorBrewer)
  library(org.Hs.eg.db)
  library(Matrix)
  library(tictoc)
  library(AnnotationDbi)
  library(DT)
  library(EnhancedVolcano)
  library(sparseMatrixStats)
  })

# Set seed to your favorite number for reproducibility
set.seed(21)
```

## Set working directory

Uncomment commands below to see what directory you are currently working in and set the correct one

```{r}
# getwd() 
# setwd('~/workshops/navigating-the-single-cell-landscape-a-comprehensive-workshop-on-scrnaseq/day-1/')
```

## Load Data

### Load Seurat object

```{r}
# 'se' or 'srobj' are common abbreviations for Seurat objects
srobj <- readRDS('../data/d8e35450-de43-451a-9979-276eac688bce.rds')

# 'genes' is a gene conversion table to convert ENSG to readable gene symbols
genes <- read_csv('../data/cov_flu_gene_names_table.csv') 
```

```{r}
# Ensure that mtx or your desired data is in integer format. 
mtx <- srobj@assays$RNA@data
# NOTE: Run command below to ensure data is class 'numeric'
# class(mtx@x)
mtx[1:10,1:10] # Don't put normalized data into DESeq

# Set rownames to be gene names
rownames(mtx) <- genes[match(row.names(mtx), genes$index), ]$feature_name

# Remake Seurat object
se <- CreateSeuratObject(counts = mtx, meta.data = srobj@meta.data)
se
```

Set color palette

```{r}
pal <- paletteMartin
names(pal) <- sort(unique(se$Celltype))
```

## Analysis

### Seurat pre-processing

```{r, warnings = FALSE}
se <- se %>%
    NormalizeData(verbose = FALSE) %>%
    FindVariableFeatures(
        method = "vst",
        nfeatures = 3000,
        verbose = FALSE) %>%
    ScaleData(verbose = FALSE) %>%
    RunPCA(verbose = FALSE) %>%
    RunUMAP(dims = 1:30, verbose = FALSE, n.components=3L)

```

Visualize PCs

```{r, warnings = FALSE}
# Elbow plot of PCs
# NOTE: First 10-15 PCs hold most of the information
ElbowPlot(se, ndims = 30)
```

```{r, warnings = FALSE}
# Group cells by annotation
DimPlot(
    se,
    group.by = c("Celltype"),
    label = TRUE,
    cols = pal)
```

Modify strings with special characters to avoid complications later

```{r}
se@meta.data <- se@meta.data %>%
  mutate(
    Celltype = str_replace(Celltype, ", ", "_"),
    Celltype = str_replace(Celltype, "G\\-", "Gneg"),
    Celltype = str_replace(Celltype, "G\\+", "Gpos")
  )

```

Check to make sure strings were modified correctly before next steps

```{r}
unique(se@meta.data$Celltype)
```

### Aggregate Expression

The AggregateExpression() function arranges the cell by gene matrix to group gene counts by the Sample ID and labelled Celltype of each cell. It outputs either a sparse matrix or a new seurat object if `return.Seurat = TRUE`. **Aggregation is the pseudobulking step where genes are summed across cells per celltype per sample.**

```{r}
# Here we separate the dataset into two subsets
# CD8 and CD4 T cells
Idents(se) <- se@meta.data$Celltype
cd4sr <- subset(se, idents = c('CD4_EM-like', 'CD4_non-EM-like'))
cd8sr <- subset(se, idents = c('CD8_non-EM-like', 'CD8_EM-like'))

# Filter for genes with 0 counts
cd4sr <- cd4sr[sparseMatrixStats::rowSums2(cd4sr@assays$RNA$data) > 0, ]
cd8sr <- cd8sr[sparseMatrixStats::rowSums2(cd8sr@assays$RNA$data) > 0, ]


cd4_pseudobulk <- AggregateExpression(cd4sr, group.by = 'Sample ID')$RNA
cd8_pseudobulk <- AggregateExpression(cd8sr, group.by = 'Sample ID')$RNA
dim(cd4_pseudobulk)
dim(cd8_pseudobulk)
```

```{r}
# Save intermediate files because they might be useful later.
## TKTK : put at top or in "save" section
dir.create('pseudobulk_analysis')
dir.create('pseudobulk_analysis/data')
```

```{r}
## TKTK : put at top or in "save" section
list.files('pseudobulk_analysis/data')
```

## Run DESeq2

### Explanation

DESeq2 takes 3 main parameters.

1.  countData = A subset of the aggregated counts. Counts have to be whole numbers.

2.  colData = Sample metadata.

3.  design = Tells the DESeq function what comparisons to make.

```{r}
# Here we run DESeq2, the classic differential expression package.

# 2 - Subset the sample metadata to match the sample x gene matrix.
sample_info <- strsplit(colnames(cd4_pseudobulk), " ")

lvls <- c("Normal", "Flu", "nCoV")
colData <- data.frame(
  sample = colnames(cd4_pseudobulk),
  condition = factor(sapply(sample_info, `[`, 1), levels = lvls)
)
DT::datatable(colData)

rownames(colData) <- colnames(cd4_pseudobulk)

# Note: If you encounter an error here, make sure dplyr is installed/running.

# Set "sample" variable to join the dataframes on
se@meta.data <- se@meta.data %>%
  dplyr::rename("sample" = "Sample ID")

# Join the metadata in se@meta.data to colData dataframe
colData <- colData %>%
  left_join(se@meta.data %>%
              dplyr::select('sample', 'Disease group') %>%
              distinct()
)
```

```{r}
# Create the DESeq object, where tests can be run. 
## Check out the documentation online for more.
dds <- DESeqDataSetFromMatrix(countData = cd4_pseudobulk,
                                colData = colData,
                                design = ~ condition)
# this runs the test
dds <- DESeq(dds)
dds

## Plot dispersion estimates
# DESeq2 assumes that genes with similar expression levels have similar dispersion.
plotDispEsts(dds)
```

## Results

### What does this mean?

Results function examples:

-   res \<- results(dds)

-   res \<- results(dds, contrast = c("metadata_var", "opt1", "opt2"))

-   res \<- results(dds, name = "defined_condition")

Results output guide:

-   Positive log2fold change are up-regulated

-   Negative are down-regulated

-   Can set the p-value to a certain threshold

```{r}
results(dds, contrast = c("condition", "Flu", "Normal"))
```

```{r}
# run 'resultsNames(dds)' to see "name" options
# current options: "condition_Flu_vs_Normal"  "condition_nCoV_vs_Normal"
# this pulls results from the DESeq object
res <- results(dds, name = "condition_Flu_vs_Normal")
res

# Summary function 
summary(res)
```

Save Results\
**NOTE: Save all data so if a collaborator asks what the comparison was, you have the header stored or rerun analysis.**

```{r}
# Uncomment below to create results folder
# dir.create('pseudobulk_analysis/results')

# Save as a R object
saveRDS(object = res, 
        file = 'pseudobulk_analysis/results/cd4_annot_pseudobulk_results.rds')

# Filtering and rearranging for plotting
restbl <- res %>% 
  data.frame %>% 
  rownames_to_column('gene')

# Write data frame results to CSV
write.csv(
  restbl,
  file='pseudobulk_analysis/results/cd4_annot_pseudobulk_results.csv'
  )
```

## Visualize Results

Volcano plot is often the ultimate goal of differential expression analysis.

### From CSV object

```{r}
res <- read_csv('pseudobulk_analysis/results/cd4_annot_pseudobulk_results.csv')
```

```{r}
library(EnhancedVolcano)
EnhancedVolcano(res,
                lab = res$gene,
                x = 'log2FoldChange',
                y = 'padj',
                xlim = c(-8, 8),
                ylim = c(0, 5),
                title = 'Volcano Plot: CD4 T cells',
                subtitle = 'Normal < -  - - -  | -  - - -  > Flu',
                xlab = 'Log2 Fold Change',
                ylab = '-log10 FDR',
                pCutoff = 0.05,
                FCcutoff = 1.5,
                pointSize = c(ifelse(res$padj < 0.05 & abs(res$log2FoldChange) > 1.5, 1.5, 1)),
                labSize = 4.0,
                col = c('grey30', 'forestgreen', 'royalblue', 'red2'),
                colAlpha = 1,
                legendLabels=c('Not Significant', 'Log2FC', 'P-Value', 'Log2FC & P-Value'),
                legendPosition = 'right',
                legendLabSize = 14,
                drawConnectors = TRUE,
                widthConnectors = 0.5,
                colConnectors = 'grey30')

```

TD: List notable genes, highlight where they are found, what they do, etc

### From RDS object

```{r}
res <- readRDS('pseudobulk_analysis/results/cd4_annot_pseudobulk_results.rds')
```

Volcano plot is often the ultimate goal of differential expression analysis.

```{r}
library(EnhancedVolcano)
EnhancedVolcano(res,
                lab = rownames(res),
                x = 'log2FoldChange',
                y = 'padj',
                xlim = c(-8, 8),
                ylim = c(0, 5),
                title = 'Volcano Plot: CD4 T cells',
                subtitle = 'Normal < -  - - -  | -  - - -  > Flu',
                xlab = 'Log2 Fold Change',
                ylab = '-log10 FDR',
                pCutoff = 0.05,
                FCcutoff = 1.5,
                pointSize = c(ifelse(res$padj < 0.05 & abs(res$log2FoldChange) > 1.5, 1.5, 1)),
                labSize = 4.0,
                col = c('grey30', 'forestgreen', 'royalblue', 'red2'),
                colAlpha = 1,
                legendLabels=c('Not Significant', 'Log2FC', 'P-Value', 'Log2FC & P-Value'),
                legendPosition = 'right',
                legendLabSize = 14,
                drawConnectors = TRUE,
                widthConnectors = 0.5,
                colConnectors = 'grey30')

```

TD: List notable genes, highlight where they are found, what they do, etc

## Automate this for pre-annotated cell types

### Aggregate gene counts for each sample

```{r}
# TKTK: how do I filter for 0 gene counts of a seurat obj?
# Filter genes with zero counts
## Start loop, then filter
annot_pseudobulk <- AggregateExpression(
  se, # object name
  group.by = c('Sample ID','Celltype')
  )$RNA # desired assay
# NOTE: Can add "return.seurat = TRUE" and assign this to a new Seurat obj
```

```{r}
# We have to rearrange the data somewhat to get it into the DESeq object. colData is the sample-level metadata

# Celltype variable is in question
sample_info <- strsplit(colnames(annot_pseudobulk), "_")

# TKTK: figure out consistent factor order
# Prep variables
lvls <- c("Normal", "Flu", "nCoV")
ftr <- str_split(colnames(annot_pseudobulk), pattern = " ", simplify = TRUE)

colData <- data.frame(
  sample = colnames(annot_pseudobulk),
  condition = factor(ftr[, 1], levels = lvls),
  donor_id = sapply(sample_info, `[`, 1),
  CT = sapply(sample_info, `[`, 2)
)

# Ensure unique rownames in colData for DESeqDataSet
rownames(colData) <- colnames(annot_pseudobulk)

colData <- colData %>%
  left_join(se@meta.data %>%
  dplyr::select(sample) %>%
    distinct()
) %>%
  column_to_rownames(var = 'sample')
```

```{r}
# Use lapply function to loop through Celltypes
lapply(unique(colData$CT), function(cluster) {
  split <- str_split_fixed(colnames(annot_pseudobulk),pattern='_',n=2)[,2]
  bulk_subset <- annot_pseudobulk[,split %in% cluster ]
  bulk_subset <- bulk_subset[sparseMatrixStats::rowSums2(bulk_subset@assays$RNA$data) > 0, ]
  data_subset <- colData %>% filter(CT %in% cluster) 
  data_subset$condition
  dds <- DESeqDataSetFromMatrix(countData = bulk_subset,
                                colData = data_subset,
                                design = ~ condition)
  
  cluster <- stringr::str_replace(cluster, " ", "_")
  c <- stringr::str_replace(cluster, "\\-", "_")
  dds <- DESeq(dds)
  # resultsNames(dds)
  res <- results(dds, name = "condition_Flu_vs_Normal")  

  r <- str_replace_all(c, '/', '.')
  saveRDS(
    res,
    glue::glue("pseudobulk_analysis/results/{r}_fluVnorm_annot_pseudobulk_results.rds"))
  
  restbl <- res %>%
  data.frame %>%
  rownames_to_column('gene')
  write_csv(
    restbl,
    glue::glue("pseudobulk_analysis/results/{r}_fluVnorm_annot_pseudobulk_results.csv"))
})

# TD: openxlsx package
# save each csv file individually, then loop through them again and put them into one excel file
```

Save to XLSX

```{r}
# TKTK pick this up later
# ls <- unique(colData$CT)
# clust_xlsx <- lapply(names(ls), function(c){
#   # print(c)
#   # extract cluster
#   print(c)
# })

```

```{r}
res_ls <- list.files('pseudobulk_analysis/results/', pattern = "*.rds")
```

```{r}
suppressMessages({

# dir.create('pseudobulk_analysis/figures/')
lapply(res_ls, function(file) {
    res_df <- readRDS(glue::glue('pseudobulk_analysis/results/{file}'))
    pdf(glue::glue('pseudobulk_analysis/figures/',strsplit(file,split='_')[[1]][1],'_volcano.pdf'),width=14,height=10)

    print(EnhancedVolcano(res_df,
                lab = res_df$gene,
                x = 'log2FoldChange',
                y = 'padj',
                xlim = c(-8, 8),
                ylim = c(0, 5),
                title = glue::glue('Volcano Plot: ',strsplit(file,split='_')[[1]][1]),
                subtitle = 'try again',
                xlab = 'Log2 Fold Change',
                ylab = '-log10 FDR',
                pCutoff = 0.05,
                FCcutoff = 1.5,
                pointSize = c(ifelse(res_df$padj < 0.05 & abs(res_df$log2FoldChange) > 1.5, 1.5, 1)),
                labSize = 4.0,
                col = c('grey30', 'forestgreen', 'royalblue', 'red2'),
                colAlpha = 1,
                legendLabels=c('Not Significant','Log2FC','P-Value','Log2FC & P-Value'),
                legendPosition = 'right',
                legendLabSize = 14,
                drawConnectors = TRUE,
                widthConnectors = 0.5,
                colConnectors = 'grey30'))
    dev.off()
})
    })
```

```{r}
list.files('pseudobulk_analysis/figures/')
```

## CD8

```{r}
# Here we run DESeq2, the classic differential expression package.
colnames(cd8_pseudobulk)
```

```{r}
# colData is the sample-level metadata
sample_info <- strsplit(colnames(cd8_pseudobulk), " ")

colData <- data.frame(
  sample = colnames(cd8_pseudobulk),
  condition = sapply(sample_info, `[`, 1)
)
DT::datatable(colData)

rownames(colData) <- colnames(cd8_pseudobulk)

colData <- colData %>%
  left_join(se@meta.data %>%
  dplyr::select(sample) %>%
    distinct()
) %>%
  column_to_rownames(var = 'sample')
DT::datatable(colData)
```

```{r}
# This function creates the DESeq object
dds <- DESeqDataSetFromMatrix(countData = cd8_pseudobulk,
                                colData = colData,
                                design = ~ condition)

# This runs the test
dds <- DESeq(dds)
dds

# run 'resultsNames(dds)' to see "name" options
# current options: "condition_Flu_vs_Normal"  "condition_nCoV_vs_Normal"
# this pulls results from the DESeq object
res <- results(dds, name = "condition_Normal_vs_Flu")
res

# Filtering and rearranging for plotting
restbl <- res %>% 
  data.frame %>% 
  rownames_to_column('gene') %>% 
  filter(pvalue < 0.05)

# save the table!
write.csv(
  restbl,
  file='pseudobulk_analysis/results/cd8_annot_pseudobulk_results.csv')
```

```{r}
res <- res %>% 
  data.frame %>% 
  rownames_to_column('gene') %>% 
  filter(pvalue < 0.05) %>% 
  dim
```

### Read and bind files

```{r}
grep('annotation',list.files('./day-1/pseudobulk_analysis/results'))

annots <- list.files('pseudobulk_analysis/results')[grepl('annotation_',list.files('pseudobulk_analysis/results'))]
clusts <- list.files('pseudobulk_analysis/results')[grepl('cluster-',list.files('pseudobulk_analysis/results'))]

annots = annots[c(-1,-8)]
```

```{r}
setwd('pseudobulk_analysis/results')

read_and_bind_files <- function(file_list) {
  # Function to extract cluster name and read file
  read_file <- function(file_name) {
    cluster_name <- str_extract(file_name, ".*(?=_annotation_pseudobulk_results\\.csv)")
    read_csv(file_name) %>%
      mutate(cluster = cluster_name) 
  }
  
  # Apply the function to each file and bind rows
  map_dfr(file_list, read_file)
}

combined_data1 <- read_and_bind_files(annots)

read_and_bind_files <- function(file_list) {
  # Function to extract cluster name and read file
  read_file <- function(file_name) {
    cluster_name <- str_extract(file_name, ".*(?=_pseudobulk_results\\.csv)")
    read_csv(file_name) %>%
      mutate(cluster = cluster_name) 
  }
  
  # Apply the function to each file and bind rows
  map_dfr(file_list, read_file)
}

combined_data2 <- read_and_bind_files(clusts)

setwd('../..')

```

```{r}
# To confirm original working directory
getwd()

```

```{r}
write_csv(
  combined_data1,
  './day-1/pseudobulk_analysis/results/combined_annot_pseudobulk_cohort_DE.csv')
write_csv(
  combined_data2,
  './day-1/pseudobulk_analysis/results/combined_clusters_pseudobulk_cohort_DE.csv')

bucket <- 'gs://fc-f188c449-d5f6-45c3-807f-540127e67fe7'

system(sprintf('gsutil -m cp -r pseudobulk_analysis/ %s',bucket))

```

Suggestions:

<!-- # TD: -->

<!-- # after commas, add a space -->

<!-- # make sure code doesn't pass this line >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> -->

Notes: What is pseudobulk? - leverages the resolution offered by single-cell technologies to define the labels, and combines it with the statistical rigor of existing methods for DE analyses involving a small number of sample - aggregate the counts for those cells belonging to a particular replicate or sample and not at the ssingle cell level - we have one count value for a gene fro one replicate or sample, more like a bulk count matrix why are we pseudobulking our data? - single cell has a lot of zeros and a complicated distribution \> brings heterogeneity - single cell methods identify highly expressed genes as differentially expressed which brings low sensitivityy for genes that have low expression - single cell methods inflate p values, but cells cannot be considered truly independent - pseudobulking can reduce number of zeros and leverage "statistical rigor" of bulk analysis techniques, - each sample is represented no more than once for each condition, avoiding problems from unmodelled correlations between samples

2.  load annotated, seurat object

-   use doublet determining info if you can

3.  preprocess data
4.  run seurat's normalization

`*The`echo: false\` option disables the printing of code (only output is displayed).\*

```{r}
sessionInfo()
```
