---
title: "6 - Clustering"
format: html
editor: visual
author: Rose Hedderman
---

# Clustering

## Introduction

This notebook picks up on the cell filtering from the QC notebook and circles back to some of the PCA content from notebook 4. Below, we cover essential Seurat functions as well as clustering metrics that give quantitative guidelines to how well the clustering process is performing.

### Key Takeaways

-   one

-   two

-   three

### Glossary

### Resources

1.  [Current best practices in single-cell RNA-seq analysis: a tutorial](https://www.embopress.org/doi/full/10.15252/msb.20188746)
2.  [Bioconductor](https://bioconductor.org/books/3.13/OSCA.basic/quality-control.html)
3.  [Single Cell Best Practices](https://www.sc-best-practices.org/preprocessing_visualization/quality_control.html)

## Load Libraries and Data

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Libraries

```{r}
if (!requireNamespace("tidyverse", quietly = TRUE))
    install.packages('tidyverse')
if (!requireNamespace("Seurat", quietly = TRUE))
    install.packages('Seurat')
if (!requireNamespace("colorBlindness", quietly = TRUE))
    install.packages('colorBlindness')
if (!requireNamespace("RColorBrewer", quietly = TRUE))
    install.packages('RColorBrewer')
if (!requireNamespace("cluster", quietly = TRUE))
    install.packages('cluster')
```

```{r}
suppressPackageStartupMessages({
  library(dplyr)
  library(Seurat)
  library(tidyverse)
  library(RColorBrewer)
  library(colorBlindness)
  library(DoubletFinder)
  library(cluster)
})
set.seed(687)
```

Load Data

```{r}
# Load the Seurat object with doublet and batch information
se <- readRDS('../data/workshop-data-withQuality.rds')
se 

# Set color palette
pal <- paletteMartin
names(pal) <- sort(unique(se$Celltype))
```

We left off (last session) filtering out the poor quality data without regard for its distribution. Last week, we learned how principle components are calculated, what a latent space is, and defined a kNN (k-nearest neighbors) graph.

To review those:

We take a cell x gene matrix, normalize it, and reduce its dimensionality using PCA. We looked at an Elbow plot to determine the best number of PCs that accurately show the variance explained. After selecting the top 30 PCs, we generated a k-nearest neighbors (kNN) graph to represent the relationships between cells based on their gene expression profiles and ran FindClusters() to identify clusters of cells based on their neighborhood relationships. Kyle introduced Harmony as an integration technique to correct for batch effects and I just went over QC metrics including doublet detection that help us understand the quality and content of our data.

Today, we're going to: 1. Look at the FindClusters() function, its default parameters, and the algorithm(s) it relies on. 2. Plot a UMAP

## Overview

**PCA** - A dimensionality reduction technique that reduces the number of dimensions in a dataset while retaining as much variance as possible. The first principal component accounts for the most variance in the data, and each subsequent component accounts for less variance.

**Latent Space** - The latent space is the low-dimensional representation of the data that captures the most important features.

**kNN Graph** - A graph that represents the relationships between cells based on their gene expression profiles. Each cell is connected to its k (1, 20, 100) nearest neighbors in the graph.

## Preprocessing

### UMAP of Counts and QC Metrics

## Clustering

Before clustering, these are the preprocessing steps we took:

```{r}
# se %>%
#     NormalizeData(verbose = FALSE) %>%
#     FindVariableFeatures(
#         method = "vst",
#         nfeatures = 3000,
#         verbose = FALSE) %>%
#     ScaleData(verbose = FALSE) %>% # Scales data to have mean 0 and variance 1
#     RunPCA(verbose = FALSE) 
```

Plots:

-   PCA = scree plot or biplot

-   cluster visualization or cluster heatmaps

### PCA

Let's start by visualizing PC1 and PC2 by Celltype.

```{r, fig.width=8, fig.height=8}
# DimPlot allows us to color the latent space based on categorical values per cell, like cell type or which sample the cell is from
celltype_pca <- DimPlot(
        se,
        reduction = "pca",
        group.by = 'Celltype'
        ) 

celltype_pca
```

Construct the kNN graph:

FindNeighbors() is the Seurat function that calculates the K-nearest neighbors of each cell in PCA space. The number of neighbors used for this calculation is controlled by the k.param parameter in the FindNeighbors function. The default value is 30. The function also calculates the distance between each cell and its neighbors. The function computes pairwaise distances between cells based on their gene expression common ex: euclidean distance, manhattan distance, Pearson correlation distance, cosine similarity. choice matters.

From [BioStars](https://www.biostars.org/p/9572463/) FindNeighbors() is a function that is used to find the nearest neighbors of your single cell data point within a dataset. It works by calculating the neighborhood overlap (Jaccard index) between every cell and its k. param nearest neighbors. It's often employed in various applications such as anomaly detection, and dimensionality reduction. The concept is that given a data point, you want to identify the closest data points to it based on some similarity metric, such as Euclidean distance or cosine similarity. This helps to identify similar points in the dataset, which can be useful for making predictions or understanding the distribution of the data.\*

### FindNeighbors()

The default values of FindNeighbors() are: 

`FindNeighbors(   
  object,   
  reduction = "pca",   
  dims = 1:10,   
  assay = NULL,   
  features = NULL,   
  k.param = 20,   
  return.neighbor = FALSE,   
  compute.SNN = !return.neighbor,   
  prune.SNN = 1/15,   
  nn.method = "annoy",   
  n.trees = 50,   
  annoy.metric = "euclidean",   
  nn.eps = 0,   
  verbose = TRUE,   
  do.plot = FALSE,   
  graph.name = NULL,   
  l2.norm = FALSE,   
  cache.index = FALSE,   
... )`

Let's modify these to fit our analysis:

```{r}
se_1 <- se %>% 
    FindNeighbors( 
      object = se,
      reduction = "pca",
      dims = 1:30,
      k.param = 30,
      verbose = FALSE
    )
```

```{r}
se_1@graphs
```

TKTK: is there any reason or way to look at the neighbors computed?

### FindClusters

From BioStars: *FindClusters() is a function used for clustering data points into groups or clusters based on their similarity. It uses a graph-based clustering approach and a Louvain algorithm. Clustering is an unsupervised learning technique where the algorithm groups similar cells together without any predefined labels. The goal is to find patterns and structure in your data. The number of clusters and the algorithm used can vary based on the problem and data characteristics. Common clustering algorithms include K-means, hierarchical clustering, and DBSCAN.*

FindClusters() is used for identifying clusters of cells based on their neighborhood relationships typically obtained from PCA or t-SNE. It inputs the graph made from FindNeighbors and. outputs cluster assignments for each cell found at `se@meta.data$seurat_clusters`.

There are a couple of popular clustering algorithms. There is no one way to cluster as clustering is a means of looking at the data from different angles. The most popular clustering algortihms are the louvain algorithm, leiden algorithm, hierarchical clustering, and k-means clustering. Seruat uses the Leiden algorithm by default which is an improvement on the Louvain algorithm.

The resolution parameter controls the granularity of the clustering. Higher values of resolution will result in more clusters, while lower values will result in fewer clusters. The default value is 0.8.

In clustering, the goal is not to see how many clusters you can pull apart but it is an iterative process. especially in the first pass, you want to pull apart main cell groups such as epithelial cells and immune cells so you can further refine the clustering to get more granular cell types in the next iteration.

After clustering, we'll review some cluster validation techniques to qualitatively and quantitatively check the quality of the clustering results.

#### FindClusters

The default values for FindClusters() are: FindClusters( object, graph.name = NULL, cluster.name = NULL, modularity.fxn = 1, initial.membership = NULL, node.sizes = NULL, resolution = 0.8, method = "matrix", algorithm = 1, n.start = 10, n.iter = 10, random.seed = 0, group.singletons = TRUE, temp.file.location = NULL, edge.file.name = NULL, verbose = TRUE, ... ) where when 'algorithm' = 1 original Louvain algorithm = 2 Louvain algorithm with multilevel refinement = 3 SLM (Smart Local Moving) algorithm = 4 Leiden algorithm *See `?FindClusters` for more information*

We modify those to fit our object:

```{r}
se_1 <- FindClusters(
      object = se_1,
      resolution = c(0.01, 0.05, 0.1, 0.15, 0.2,0.25)) 
# Find clusters based on nearest neighbors at a resolution of 0.5
```

#### Louvain vs Leiden

The Louvian algorithm was developed in 2008 and is a most popular community detection algorithm widely used in scRNA-seq. *It recursively merges communities into a single node and executes the modularity clustering on the condensed graphs.*([Zhang](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC10158997/)) Both Seurat and scanpy use Louvain as the default clustering algorithm.

<img src="../data/clustering.jpeg" width="900"/>\
*Leiden Algorithm*

The Leiden algorithm was published in 2020 as an improvement of the Louvain algorithm. *Leiden creates clusters by taking into account the number of links between cells in a cluster versus the overall expected number of links in the dataset. It computes a clustering on a KNN graph obtained from the PC reduced expression space. It starts with an initial partition where each node from its own community. Next, the algorithm moves single nodes from one community to another to find a partition, which is then refined. Based on a refined partition an aggregate network is generated, which is again refined until no further improvements can be obtained, and the final partition is reached.* ([Single Cell Best Practices](https://www.sc-best-practices.org/clustering/clustering.html))

#### RunUMAP

-   This function runs the UMAP algorithm on the PCA space. The dims parameter specifies which dimensions of the PCA space to use for the UMAP calculation. The default value is 1:30, which uses all dimensions. The n.components parameter specifies the number of dimensions in the UMAP embedding. The default value is 2.

```{r}
se_1 <- se_1 %>% 
    RunUMAP(dims = 1:30, verbose = FALSE) # Run UMAP 
```

#### Visualize Clusters

```{r, fig.width=15, fig.height=10}
DimPlot(
    se_1,
    group.by = c(
        "RNA_snn_res.0.01", "RNA_snn_res.0.05",
        "RNA_snn_res.0.1", "RNA_snn_res.0.15",
        "RNA_snn_res.0.2", "RNA_snn_res.0.25"),
    label = TRUE)
```

#### Different Resolutions

0.01 vs 0.05 Resolution

```{r, fig.width=15, fig.height=5}
DimPlot(
    se_1,
    group.by = c(
        "RNA_snn_res.0.01", "RNA_snn_res.0.05", "Celltype"),
    label = TRUE)
```

In the next session, we'll look at the difference in resolutions by gene expression. For now, let's go with 0.05 and perform cluster validation.

## Cluster Metrics

### Cluster Diversity

1 - Number of Cells in each Cluster

```{r}
seurat_clusters <- "RNA_snn_res.0.05"
diversityPerGroup <- function(df, species, group, diversity_metric = 'simpson') {
  # Convert strings to symbols for curly-curly operator
  species_sym <- rlang::sym(species)
  group_sym <- rlang::sym(group)
  # Count groups per species directly using curly-curly
  tierNcount <- df %>%
    group_by({{species_sym}}) %>%
    count({{group_sym}}, name = "n") %>% ungroup
  # Pivot table to allow vegan::diversity call
  tierNwide <- tierNcount %>%
    pivot_wider(names_from = {{group_sym}}, values_from = n, values_fill = list(n = 0))
  # Use rownames of species for the diversity function, which needs a dataframe
  tierNwide_df <- as.data.frame(tierNwide)
  # species column must be first
  tierNwide_df <- tierNwide_df %>% select({{species}}, everything())
  rownames(tierNwide_df) <- tierNwide_df[, 1]
  tierNwide_df <- tierNwide_df[, -1]
  # Calculate diversity
  diversity_values <- vegan::diversity(tierNwide_df, index = diversity_metric)
  # Prepare result as a dataframe
  result <- data.frame(
    species = rownames(tierNwide_df),
    diversity = diversity_values,
    row.names = NULL
  )
  # Rename diversity column
  names(result)[1] <- species
  names(result)[2] <- sprintf('%s_diversity', group)
  return(result)
}

# Calculate simpson's diversity per cluster
clusterMetrics <- diversityPerGroup(se_1@meta.data,
                        species = 'RNA_snn_res.0.05',
                        group = 'Sample ID',
                        diversity_metric = 'simpson')

# Calculate number of cells per cluster and join to metrics table
clusterMetrics <- clusterMetrics %>% left_join(se_1@meta.data %>% count(RNA_snn_res.0.05))

# clusterMetrics

# p1 <- ggplot(clusterMetrics, aes(x = Celltype, y = n)) +
#   geom_bar(stat = "identity", fill = 'black') +
#   scale_y_log10() +
#   labs(x = "Cell Type", y = "Cell Number (log scale)") +
#   theme_minimal() +
#   theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
library(viridis)
seurat_clusters <- "RNA_snn_res.0.05"
clusterMetrics$seurat_clusters <- as.numeric(clusterMetrics$RNA_snn_res.0.05)

lollipop <- ggplot(clusterMetrics, aes(x = seurat_clusters, y = n)) +
  geom_segment(aes(x = seurat_clusters, xend = seurat_clusters, y = 0, yend = n),
               size = 1.5, color = 'grey80') + # Draw lines for lollipops
  geom_point(aes(colour = `Sample ID_diversity`), size = 5) + # Add colored lollipop 'heads', coloring by 'Sample ID_diversity'
  scale_y_log10() +
  scale_x_continuous(breaks = seq(0,20)) + 
  scale_colour_viridis(option = "C", name = "Sample ID Diversity", direction = 1, limits = c(0,1)) + # Colorblind-friendly, vibrant color palette
  theme_minimal(base_size = 10) +
  theme(legend.position = "bottom",
        axis.text = element_text(size = 12), 
        axis.title = element_text(size = 14), 
        title = element_text(size = 16)) +
  labs(x = "Seurat Clusters",
       y = "cluster size (log-scaled)",
       title = "Cluster Diversity Metrics") +
  guides(colour = guide_colourbar(title.position = "top", title.hjust = 0.5))

lollipop
```

2 - Which samples are in each cluster

\# Plot sample distribution per cluster

```{r}
# Load necessary packages
library(ggplot2)
library(dplyr)
library(tidyr)

# Assuming se_1@meta.data has columns 'seurat_clusters' and 'Sample ID'

# Prepare the data for plotting
plot_sample <- se_1@meta.data %>%
  count(RNA_snn_res.0.05, `Sample ID`) %>%
  group_by(RNA_snn_res.0.05) %>%
  mutate(proportion = n / sum(n)) %>%
  ungroup()

# Create a stacked bar plot
ggplot(plot_sample, aes(x = factor(RNA_snn_res.0.05), y = proportion, fill = `Sample ID`)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Sample ID",
       title = "Distribution of Sample IDs Across Clusters") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_manual(values = pal)

# TD: use Marc's color scheme for donors- factor analysis
```

```{r}
# Prepare the data for plotting
plot_batch <- se_1@meta.data %>%
  count(RNA_snn_res.0.05, batch) %>%
  group_by(RNA_snn_res.0.05) %>%
  mutate(proportion = n / sum(n)) %>%
  ungroup()

# Create a stacked bar plot
ggplot(plot_batch, aes(x = factor(RNA_snn_res.0.05), y = proportion, fill = batch)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(x = "Seurat Clusters", y = "Proportion", fill = "Batch",
       title = "Distribution of Batches Across Clusters") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

3 - Stacked Bar Plot of Cluster Diversity

```{r, fig.width = 5}
p2 <- ggplot(clusterMetrics, aes(y=as.character(seurat_clusters), fill=`Sample ID_diversity`, x = 1, label = n)) +
  geom_tile(colour = "white") +
  geom_text(nudge_x = 1.5, size = 3) +
  geom_text(aes(label = signif(`Sample ID_diversity`, 2)),size = 3) +
  scale_fill_distiller(palette = "Spectral", limits = c(0,1)) + theme_classic() +
  coord_fixed(ratio = 0.25) + 
  expand_limits(x = c(0.5,3)) +
  labs(x = "Diversity            Size") +
  theme(axis.text.y = element_text(hjust = 1, vjust = 0.5, size = 12),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_text(size = 15),
        legend.key.size = unit(1, 'cm'),
        legend.title = element_text(size=10), 
        legend.text = element_text(size=10)
  )
p2
```

### Silhouette Analysis

As covered in the last workshop, silhouette analysis is a way to measure how similar an object is to its own cluster compared to other clusters. The silhouette value ranges from -1 to 1, where a high value indicates that the object is well matched to its own cluster and poorly matched to neighboring clusters.

```{r}
seurat_clusters <- se_1@meta.data$RNA_snn_res.0.05

pca_embeddings <- Embeddings(se, reduction = 'pca')

# Calculate silhouette widths
sil_scores <- silhouette(x = as.numeric(seurat_clusters), dist = dist(pca_embeddings))

# Extract silhouette scores
silhouette_data <- as.data.frame(sil_scores)
# Recover cell type names
silhouette_data$seurat_clusters <- as.character(seurat_clusters)

row.names(silhouette_data) <- row.names(pca_embeddings)

silhouette_arranged <- silhouette_data %>% 
  group_by(seurat_clusters) %>% 
  arrange(-sil_width)
```

```{r}
overall_average <- silhouette_arranged %>% 
  ungroup %>% 
  summarize(ave = as.numeric(mean(sil_width))) %>% 
  pull(ave)

full_plot <- ggplot(silhouette_arranged, 
                    aes(x = sil_width, 
                        y = seurat_clusters, 
                        fill = seurat_clusters, 
                        group = seurat_clusters)) +
    geom_bar(stat = "identity", position = 'dodge2') +
    geom_vline(xintercept = overall_average,
               color = 'red',
               linetype = 'longdash') +
    theme_minimal() +
    labs(title = "Silhouette Analysis",
        y = "Cluster",
        x = "Silhouette width",
        fill = "Cluster") +
    theme(axis.text.y = element_text(hjust = 1, vjust = 0.5, size = 20),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_text(size = 20),
        legend.position = "None")

full_plot
```

Look at silhouette scores on a UMAP

```{r, fig.width = 10, fig.height = 5}
d5 <- DimPlot(se_1,
        reduction='umap',
        group.by='RNA_snn_res.0.05')

se_1$CellID <- row.names(se_1@meta.data)

sil_ids <- silhouette_data %>% rownames_to_column('CellID') %>% left_join(se_1@meta.data, by='CellID')
head(silhouette_data)
head(se_1@meta.data)
se_1 <- AddMetaData(se_1, sil_ids)

FeaturePlot(se_1, feature = "sil_width") + ggtitle('Silhouette width') + scale_color_viridis_c(limits = c(-1,1), option = "magma") | d5
# TD: change color palette
```

```{r, fig.width=10, fig.height=5}
library(ggplot2)

# Convert the 'batch' variable to a character
se@meta.data$batch <- as.character(se@meta.data$batch)
d1 <- DimPlot(se,
        reduction='umap',
        group.by='batch')

d2 <- DimPlot(se,
        reduction='umap',
        group.by='DF_class')

d3 <- DimPlot(se,
        reduction='umap',
        group.by='Sample ID')

d4 <- DimPlot(se,
        reduction='umap',
        group.by='Celltype')

d1 | d2
d3 | d4
```

## Session Info

```{r}
sessionInfo()
```
