---
title: "5 - Quality Control"
format: html
editor: visual
author: Rose Hedderman
---

# Quality Control

## Introduction

This notebook reviews the quality control steps recommended at the beginning and at each subsequent annotation phase. In order to denoise a sparse cell by gene matrix, we take out unhelpful and distracting cell data to create a better representation of an experiment. In this notebook, we will look at UMI and gene counts, filter out cells with high mitochondrial levels, investigate potential doublets (using DoubletFinder), and compare the cell by gene distribution before and after filtering.

### Key Takeaways

-   one

-   two

-   three

### Glossary

**Quality Control:**

Quality control is the process of removing problematic cells from our count matrix. Looking at metrics such as counts of genes and barcodes, proportions of various gene types, and running analysis tools to find abnormalities such as doublets make up a common QC workflow.

**Why are mitochondrial genes highly expressed and found in many datasets?**

There are often disproportionately high mitochondrial cells in many datasets because cells upregulate mitochondrial genes during stress (such as during library prep) and near death.

From Bioconductor:

*"High proportions are indicative of poor-quality cells (Islam et al. [2014](https://bioconductor.org/books/3.13/OSCA.basic/quality-control.html#ref-islam2014quantitative); Ilicic et al. [2016](https://bioconductor.org/books/3.13/OSCA.basic/quality-control.html#ref-ilicic2016classification)), presumably because of loss of cytoplasmic RNA from perforated cells. The reasoning is that, in the presence of modest damage, the holes in the cell membrane permit efflux of individual transcript molecules but are too small to allow mitochondria to escape, leading to a relative enrichment of mitochondrial transcripts."*

<https://bioconductor.org/books/3.13/OSCA.basic/quality-control.html>

**Doublet:**

A doublet is a data point read by the sequencer as a single-cell droplet but likely contains 2 or more cells in one droplet. These cause confusion in the gene expression distribution especially when cells of two different types (different expected gene expression profiles) are in the same droplet.

**Heterotypic doublets vs Homotypic doublets**

A heterotypic doublet is a doublet with cells from distinct gene expression profiles that are likely different cell types.

A homotypic doublet is a doublet with cells with similar gene expression profiles that are not necessarily different cell types but are suspicious because they express around double the amount that other cells do.

### Resources

1.  [Current best practices in single-cell RNA-seq analysis: a tutorial](https://www.embopress.org/doi/full/10.15252/msb.20188746)
2.  [DoubletFinder](https://github.com/chris-mcginnis-ucsf/DoubletFinder)
3.  [Bioconductor](https://bioconductor.org/books/3.13/OSCA.basic/quality-control.html)
4.  [Single Cell Best Practices](https://www.sc-best-practices.org/preprocessing_visualization/quality_control.html)

## Loading Libraries and Data

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
if (!requireNamespace("tidyverse", quietly = TRUE))
    install.packages('tidyverse')
if (!requireNamespace("Seurat", quietly = TRUE))
    install.packages('Seurat')
if (!requireNamespace("colorBlindness", quietly = TRUE))
    install.packages('colorBlindness')
if (!requireNamespace("RColorBrewer", quietly = TRUE))
    install.packages('RColorBrewer')
```

```{r}
suppressPackageStartupMessages({
  library(Seurat)
  library(tidyverse)
  library(RColorBrewer)
  library(colorBlindness)
  library(DoubletFinder)
})
set.seed(687)
```

```{r}
se <- readRDS('../data/workshop-data.rds')
# Load a provided gene conversion table to convert ENSG to readable gene symbols
genes <- read_csv('../data/cov_flu_gene_names_table.csv') 

# Remake Seurat object
mtx <- se@assays$RNA@data
rownames(mtx) <- genes[match(row.names(mtx),genes$index), ]$feature_name

se <- CreateSeuratObject(counts = mtx, meta.data = se@meta.data)

se
```

```{r}
rm(mtx)
# Set color palette
pal <- paletteMartin
names(pal) <- sort(unique(se$Celltype))
```

## Preprocessing

### Filter out the overexpressed genes

According to *Current best practices in single-cell RNA-seq*, we want to look at the number of counts per barcode, the number of genes per barcode, and the percentage of mitochondrial genes per barcode. These distributions will help us determine the quality of the data by allowing us to see outliers. These outliers could be dying cells with high mitochondrial counts or doublets with high gene counts.

In public datasets, use `colnames()` to find the processing and metadata already analyzed.

```{r}
# Find the metadata columns of interest
colnames(se@meta.data)
```

1 - Number of UMIs

`nCount_RNA` is the number of UMIs per cell. This is a measure of the total number of transcripts detected in a cell. Cells with low `nCount_RNA` values may be dying or dead cells, while cells with high `nCount_RNA` values may be doublets. Note the figure below plots UMIs on a log10 scale.

```{r}
ggplot(se@meta.data, aes(x = nCount_RNA)) +
    geom_density(color = "#6abcb6", fill = "#6abcb6", alpha = 0.7) +
    scale_x_continuous(
        transform = "log10",
        labels = scales::unit_format(unit = "K", scale = 1e-3)) +
    theme_classic()
```

2 - Number of genes

`nFeature_RNA` is the number of genes detected in a cell. This is a measure of the total number of genes detected in a cell. Cells with low `nFeature_RNA` values may be dying or dead cells, while cells with high `nFeature_RNA` values may be doublets. Note that the figure below plots genes (features) on a log10 scale.

```{r}
ggplot(se@meta.data, aes(x = nFeature_RNA)) +
    geom_density(color = "#6abcb6", fill = "#6abcb6", alpha = 0.7) +
    scale_x_continuous(
        transform = "log10",
        labels = scales::unit_format(unit = "K", scale = 1e-3)) +
    theme_classic()
```

A distribution showing incredibly high number of genes per cell is indicative of doublets.

3 - Percentage of mitochondrial genes

Notice the object already has `Percent of mitochondrial genes` calculated. We are going to calculate them again to show how to do it.

Seurat's `PercentageFeatureSet` function calculates the percentage of a feature set in each cell. This function is useful for calculating the percentage of mitochondrial genes, ribosomal genes, or any other gene set of interest using regular expression to filter these out by gene name.

```{r}
# Calculate the percentage of mitochondrial genes
se <- PercentageFeatureSet(se, pattern = "^MT-", col.name = "perc.mt")
# Calculate the percentage of ribosomal genes
se <- PercentageFeatureSet(se, pattern = "^RPS |^RPL", col.name = "perc.ribo")
# Calculate the percentage of hemoglobin genes
se <- PercentageFeatureSet(se, pattern = "^HB[^(P)]", col.name = "perc.hb")
```

```{r, fig.width=8, fig.height=6}
# Plot Percent of mitochondrial genes by Sample
VlnPlot(se,
  group.by = "Sample ID",
  features = "perc.mt",
  # log = TRUE,
  pt.size = 0,
  ) + NoLegend()
```

```{r, fig.width=8, fig.height=6}
# Plot Percent of ribosomal genes by Sample
VlnPlot(se,
  group.by = "Sample ID",
  features = "perc.ribo",
  # log = TRUE,
  pt.size = 0
  ) + NoLegend()
```

```{r, fig.width=8, fig.height=6}
# Plot Percent of hemoglobin genes by Sample
VlnPlot(se,
  group.by = "Sample ID",
  features = "perc.hb",
  # log = TRUE,
  pt.size = 0
  ) + NoLegend()
```

```{r, fig.width=16, fig.height=6}
# Plot features by Sample together
VlnPlot(se,
  group.by = "Sample ID",
  features = c("perc.mt", "perc.ribo", "perc.hb"),
  # log = TRUE,
  pt.size = 0
  ) + NoLegend()
```

With these distributions, something notable is going on in *Flu 5*. Let's perform other quality control visualizations to see if we can find out what is happening.

Another way to visualize these distributions is:

```{r}
# Percent Mitochondrial Genes
se@meta.data %>%
  ggplot2::ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.mt)) +
    ggplot2::geom_point() +
    ggplot2::theme_classic() +
    ggplot2::scale_color_gradient(low = "yellow", high = "red", limits = c(0, 20))
```

```{r, fig.width=10, fig.height = 10}
# Percent MT Genes per sample
se@meta.data %>%
  ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.mt)) +
  geom_point() +
  facet_wrap(~`Sample ID`) +
  theme_classic() +
  scale_color_gradient(low = "yellow", high = "red", limits = c(0, 100)) +
  scale_x_continuous(
        labels = scales::unit_format(unit = "K", scale = 1e-3))

```

The authors mention they filter out UMIs with higher than 15% mitochondrial genes. This explains the cap we see at that range above.

```{r}
# Percent Ribosomal Genes
se@meta.data %>%
  ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.ribo)) +
    geom_point() +
    theme_classic() +
    scale_color_gradient(low = "yellow", high = "red", limits = c(0, 50))
```

```{r, fig.width=10, fig.height = 10}
# Percent MT Genes per sample
se@meta.data %>%
  ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.ribo)) +
  geom_point() +
  facet_wrap(~`Sample ID`) +
  theme_classic() +
  scale_color_gradient(low = "yellow", high = "red", limits = c(0, 100)) +
  scale_x_continuous(
        labels = scales::unit_format(unit = "K", scale = 1e-3))

```

```{r}
# Percent Hemoglobin Genes
se@meta.data %>%
  ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.hb)) +
  geom_point() +
  theme_classic() +
  scale_color_gradient(low = "yellow", high = "red", limits = c(0, 100))
```

```{r, fig.width=10, fig.height = 10}
# Percent hemoglobin Genes per sample
se@meta.data %>%
  ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.hb)) +
  geom_point() +
  facet_wrap(~`Sample ID`) +
  theme_classic() +
  scale_color_gradient(low = "yellow", high = "red", limits = c(0, 100)) +
  scale_x_continuous(
        labels = scales::unit_format(unit = "K", scale = 1e-3))

```

```{r}
# Plot by cell type
se@meta.data %>%
  ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = Celltype)) +
  geom_point() +
  theme_classic() 
```

```{r, fig.width=10, fig.height = 10}
# Percent MT Genes per sample
se@meta.data %>%
  ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = Celltype)) +
  geom_point() +
  facet_wrap(~Celltype) +
  theme_classic()

```

After looking at the cell type distribution, the hemoglobin concentration makes sense as it corresponds to erythocytes which are high in hemoglobin.

### Add Batch Information

Preprocessed Seurat object's will often contain information about what batch the samples were processed in as well as how doublets were calculated. From the paper for this dataset, the batch information is found in a supplementary table and the authors claimed most doublets were classified as "Uncategorized". Because they did not include the doublet information in the metadata, we will add it in this section. Doublet detection and removal is sensitive because you don't want to remove any valuable outliers but still take into consideration the noisiness of the data.

To define doublets, packages in both R and Python run per batch. We imported the batch information so we could subset the larger object and filter out doublets per batch.

```{r}
# Make a data frame and extract barcode and Sample ID metadata from se obj
info <- data.frame(Barcode = colnames(se), "Sample ID" = se@meta.data$'Sample ID')
colnames(info) <- gsub("\\.", " ", colnames(info))

# Load in batch information
batch_info <- read.csv("../data/batch_info.csv")

# Rename batch_info column names to have a space instead of "."
colnames(batch_info) <- gsub("\\.", " ", colnames(batch_info))

batch_info <- batch_info %>%
  select("Sample ID", "Experimental batch")

head(batch_info)
```

```{r}
# merge the batch_info with the info dataframe
info <- merge(info, batch_info, by = "Sample ID")

rownames(info) <- info$Barcode
info <- info %>% select(-Barcode)

# Add batch numbers to the metadata
se <- AddMetaData(se, info)
```

### DoubletFinder

There are many different packages that can be used to detect doublets. If you are familiar with Python, we use Scrublet most often. But for the sake of staying in one programming language, DoubletFinder was found to be one of the most accurate R packages. DoubletFinder uses a nearest neighbor approach to identify doublets. The package has a function called `doubletFinder` that takes in a Seurat object and returns a Seurat object with doublet information in the metadata.

```{r}
library(DoubletFinder)
# Find doublets
exp_btch <- unique(se@meta.data$'Experimental batch')
```

### How it Works

DoubletFinder looks at the expression profiles of the cells in the batch and generates two parameters pK and pANN to identify doublets by inserting artificial doublets into the data to determine which cells are real doublets. DoubletFinder combines random cell's gene expression profiles to create these "fake doublets." Then a k-nearest neighbors graph is calculated where the best pK is surveyed and calculated for each batch.

Here, you have a k-nearest neighbor graph where each cell has k neighbors. pANN is the proportion of each cell's neighbors that are artificial. A high pANN value says that a larger proportion of the cell around a specific cell are fake doublets suggesting that the cell itself is a doublet. The higher the pK, the higher the pANN needs to be to make a difference.

DoubletFinder allows you to set a threshold and will give each cell a categorical result of 'Singlet' or 'Doublet' but we suggest looking at the raw pANN values to understand the distribution of these cells and make threshold adjustments accordingly.

### Parameters

`pK parameter` = the proportion of cells that are doublets. This metric determines the accuracy of the model. The higher the pK, the more stringent the model is in classifying doublets. The lower the pK, the more lenient the model is in classifying doublets. It is the PC neighborhood size used to compute pANN, expressed as a proportion of the merged real-artificial data.

`pN parameter` = default number of doublets we expect to find (set to 0.25 by default). pN functions as the threshold.

`pANN` = proportion of artificial nearest neighbors or the "doublet score".

DoubletFinder is only sensitive to heterotypic doublets (transcriptionally-distinct doublets) so the developer suggests using a cell-type annotations (here: `batch_seurat_object@meta.data$seurat_clusters`) to model the expected proportion of homotypic (transcriptionally-similar) doublets.

```{r, echo=FALSE}
# Run doubletFinder
process_batch <- function(batch) {
  # 1 - Subset Seurat object by batch
  batch_seurat_object <- subset(se, cells = which(se@meta.data$'Experimental batch' == batch))
  
  # 2 - Process count data of that subseted Seurat object
  batch_seurat_object <- batch_seurat_object %>%
    NormalizeData() %>%
    FindVariableFeatures() %>%
    ScaleData() %>%
    RunPCA() %>%
    FindNeighbors() %>%
    FindClusters() 
  
  # 3 - Run pK identification with NO ground truth
  
  ## paramSweep: systematically explore a range of parameter values to determine the most appropriate settings for doublet detection
  ## summarizeSweep: summarizes results of paramSweep() function
  sweep.res.list_sample <- paramSweep(batch_seurat_object, PCs = 1:20, sct = FALSE)
  sweep.stats_sample <- summarizeSweep(sweep.res.list_sample, GT = FALSE)
  bcmvn_sample <- find.pK(sweep.stats_sample)
  
  # Line plot to show the pK values for BCmetric. The highest BCmetric is where the most optimal pK value is.
  # ggplot(bcmvn_sample, aes(pK, BCmetric, group = 1))+
  #   geom_point() +
  #   geom_line()
  
  # 4 - Calculate pK where pK is the proportion of cells that are doublets.
  pK <- bcmvn_sample %>%
    filter(BCmetric == max(BCmetric)) %>%
    select(pK)
  pK <- as.numeric(as.character(pK[[1]]))
  
  # 5 - nExp defines the expected pANN threshold used to make final doublet-decisions

  annotations <- batch_seurat_object@meta.data$seurat_clusters
  # annotations <- Idents(batch_seurat_object)
  homotypic.prop <- modelHomotypic(annotations) 
  nExp_poi <- round(0.075*nrow(se@meta.data))  # Assuming 7.5% doublet formation rate
  nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
  
  # 6 - Run doubletFinder
  batch_seurat_object <- doubletFinder(
    batch_seurat_object,
    PCs = 1:20,
    pN = 0.25,
    pK = pK,
    nExp = nExp_poi.adj,
    reuse.pANN = FALSE, # If TRUE, pANN will be reused from a previous run
    sct = FALSE) # If TRUE, sctransform will be used for preprocessing
  
  # 7 - Format doublet information for return dataframe
  pANN <- colnames(batch_seurat_object@meta.data) %>% 
    keep(grepl('^pANN*', colnames(batch_seurat_object@meta.data))) # pANN_0.25_0.3_1000
  DF_class <- colnames(batch_seurat_object@meta.data) %>% 
    keep(grepl('^DF.classifications*', colnames(batch_seurat_object@meta.data))) # DF.classifications_0.25_0.3_1000
  ## Extract values from pANN variable name
  params <- gsub("^pANN_", "", pANN)  # Remove "pANN_"
  params <- strsplit(params, "_")[[1]]  # Split by "_"
  pN <- params[1]  # Extract "0.1"
  pK <- params[2]  # Extract "0.1"
  doublet_run <- params[3]  # Extract "1000"
  
  ## Create new columns "pN", "pK", and "doublet_run"
  colnames(batch_seurat_object@meta.data)[colnames(batch_seurat_object@meta.data) == pANN] <- "pANN"
  colnames(batch_seurat_object@meta.data)[colnames(batch_seurat_object@meta.data) == DF_class] <- "DF_class"
  batch_seurat_object@meta.data$pN <- pN
  batch_seurat_object@meta.data$pK <- pK
  batch_seurat_object@meta.data$doublet_run <- doublet_run
  
  # 8 - Return DF of doublet information here
  df <- data.frame(
    Barcode = colnames(batch_seurat_object),
    batch = batch_seurat_object@meta.data$'Experimental batch', 
    pANN = batch_seurat_object@meta.data$'pANN', 
    DF_class = batch_seurat_object@meta.data$'DF_class',
    doublet_run = batch_seurat_object@meta.data$doublet_run,
    pK = batch_seurat_object@meta.data$pK,
    pN = batch_seurat_object@meta.data$pN
    )
  rownames(df) <- df$Barcode
  return(df)
  
}

processed_doublets <- lapply(exp_btch, process_batch)

```

```{r}
# Add doublet information to the main seurat object
test <- bind_rows(processed_doublets)
# plot pANN against batch
head(test)
ggplot(test, aes(x = pANN, fill = as.character(batch))) +
  geom_density(bins = 100, alpha = 0.5) +
  theme_classic()

table(test$batch)
```

```{r}
```

```{r}

```

```{r}
rownames(test) <- test$Barcode
test <- test %>% select(-Barcode)
se <- AddMetaData(
    object = se, 
    metadata = test
  )
```

### Perform Preprocessing

```{r}
se <- se %>%
    NormalizeData(verbose = FALSE) %>%
    FindVariableFeatures(
        method = "vst",
        nfeatures = 3000,
        verbose = FALSE) %>%
    ScaleData(verbose = FALSE, features = VariableFeatures(.)) %>%
    RunPCA(verbose = FALSE) %>%
    RunUMAP(dims = 1:30, verbose = FALSE)
```

```{r, fig.height=5}
# Plot UMAP colored by batch
DimPlot(se, reduction = "umap", group.by = 'DF_class') +
  labs(title = "UMAP Plot Colored by Batch")

```

```{r, fig.height=6, fig.width=12}
# Plot UMAP by pANN
p1 <- FeaturePlot(se, reduction = "umap", features = "pANN") +
  labs(title = "UMAP Plot Colored by pANN")
# Plot UMAP by cell type
p2 <- DimPlot(se, reduction = "umap", group.by = "Celltype") +
  labs(title = "UMAP Plot Colored by Cell Type")

p1 | p2
# DimPlot(se, reduction = "umap", group.by = "Celltype") +
#   labs(title = "UMAP Plot Colored by Batch")
```

notes: - add step at end to subset data according to numUMIs, numFeatures, and percentMT.

## Resave Seurat object

```{r}
saveRDS(se, '../data/workshop-data-withDFinfo.rds')
```

### Session Info

```{r}
sessionInfo()
```
