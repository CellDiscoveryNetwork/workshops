---
title: "5 - Quality Control"
format: html
editor: visual
author: Rose Hedderman
---

# Quality Control

## Introduction

### Information

### Key Takeaways

## Loading Libraries and Data

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
if (!requireNamespace("tidyverse", quietly = TRUE))
    install.packages('tidyverse')
if (!requireNamespace("Seurat", quietly = TRUE))
    install.packages('Seurat')
if (!requireNamespace("colorBlindness", quietly = TRUE))
    install.packages('colorBlindness')
if (!requireNamespace("RColorBrewer", quietly = TRUE))
    install.packages('RColorBrewer')
```

```{r}
suppressPackageStartupMessages({
  library(Seurat)
  library(tidyverse)
  library(RColorBrewer)
  library(colorBlindness)
  library(DoubletFinder)
})
set.seed(687)
```

```{r}
se <- readRDS('../data/workshop-data.rds')
# Load a provided gene conversion table to convert ENSG to readable gene symbols
genes <- read_csv('../data/cov_flu_gene_names_table.csv') 

# Remake Seurat object
mtx <- se@assays$RNA@data
rownames(mtx) <- genes[match(row.names(mtx),genes$index), ]$feature_name

se <- CreateSeuratObject(counts = mtx, meta.data = se@meta.data)

se
```

```{r}
rm(mtx)
# Set color palette
pal <- paletteMartin
names(pal) <- sort(unique(se$Celltype))
```

## Preprocessing

### Filter out the overexpressed genes

#### According to 'Current best practices in single-cell RNA-seq', we want to look at the number of counts per barcode, the number of genes per barcode, and the percentage of mitchondrial genes per barcode. These distributions will help us determine the quality of the data by allowing us to see outliers. These outliers could be dying cells with high mitochondrial counts or doublets with high gene counts.

In public datasets, use 'colnames()' to find the processing and metadata already analyzed.

```{r}
# Find the metadata columns of interest
colnames(se@meta.data)
```

1 - Number of UMIs nCount_RNA is the number of UMIs per cell. This is a measure of the total number of transcripts detected in a cell. Cells with low nCount_RNA values may be dying or dead cells, while cells with high nCount_RNA values may be doublets.

```{r}
ggplot(se@meta.data, aes(x = nCount_RNA)) +
    geom_density(color = "#6abcb6", fill = "#6abcb6", alpha = 0.7) +
    scale_x_continuous(
        transform = "log10",
        labels = scales::unit_format(unit = "K", scale = 1e-3)) +
    theme_classic()
```

2 - Number of genes nFeature_RNA is the number of genes detected in a cell. This is a measure of the total number of genes detected in a cell. Cells with low nFeature_RNA values may be dying or dead cells, while cells with high nFeature_RNA values may be doublets.

```{r}
ggplot(se@meta.data, aes(x = nFeature_RNA)) +
    geom_density(color = "#6abcb6", fill = "#6abcb6", alpha = 0.7) +
    scale_x_continuous(
        transform = "log10",
        labels = scales::unit_format(unit = "K", scale = 1e-3)) +
    theme_classic()
```

3 - Percentage of mitochondrial genes

Notice the object already has 'Percent of mitochondrial genes' calculated. We are going to calculate them again to show how to do it.

Seurat's "PercentageFeatureSet" function calculates the percentage of a feature set in each cell. This function is useful for calculating the percentage of mitochondrial genes, ribosomal genes, or any other gene set of interest using regular expression to filter these out by gene name.

```{r}
# Calculate the percentage of mitochondrial genes
se <- PercentageFeatureSet(se, pattern = "^MT-", col.name = "perc.mt")
# Calculate the percentage of ribosomal genes
se <- PercentageFeatureSet(se, pattern = "^RPS |^RPL", col.name = "perc.ribo")
# Calculate the percentage of hemoglobin genes
se <- PercentageFeatureSet(se, pattern = "^HB[^(P)]", col.name = "perc.hb")
```

```{r, fig.width=8, fig.height=6}
# Plot Percent of mitochondrial genes by Sample
VlnPlot(se,
  group.by = "Sample ID",
  features = "perc.mt",
  # log = TRUE,
  pt.size = 0,
  ) + NoLegend()
```

```{r, fig.width=8, fig.height=6}
# Plot Percent of ribosomal genes by Sample
VlnPlot(se,
  group.by = "Sample ID",
  features = "perc.ribo",
  # log = TRUE,
  pt.size = 0
  ) + NoLegend()
```

```{r, fig.width=8, fig.height=6}
# Plot Percent of hemoglobin genes by Sample
VlnPlot(se,
  group.by = "Sample ID",
  features = "perc.hb",
  # log = TRUE,
  pt.size = 0
  ) + NoLegend()
```

```{r}
# Plot features by Sample together
VlnPlot(se,
  group.by = "Sample ID",
  features = c("perc.mt", "perc.ribo", "perc.hb"),
  # log = TRUE,
  pt.size = 0
  ) + NoLegend()
```

With these distributions, something notable is going on in Flu 5. Let's perform other quality control visualizations to see if we can find out what is happening.

Another way to visualize these distributions is:

```{r}
# Percent Mitochondrial Genes
se@meta.data %>%
  ggplot2::ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.mt)) +
    ggplot2::geom_point() +
    ggplot2::theme_classic() +
    ggplot2::scale_color_gradient(low = "yellow", high = "red", limits = c(0, 20))
```

The authors mention they filter out UMIs with higher than 15% mitochondrial genes. This explains the cap we see at that range above.

```{r}
# Percent Ribosomal Genes
se@meta.data %>%
  ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.ribo)) +
    geom_point() +
    theme_classic() +
    scale_color_gradient(low = "yellow", high = "red", limits = c(0, 50))
```

```{r}
# Percent Hemoglobin Genes
se@meta.data %>%
  ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.hb)) +
  geom_point() +
  theme_classic() +
  scale_color_gradient(low = "yellow", high = "red", limits = c(0, 100))
```

```{r}
# Plot by cell type
se@meta.data %>%
  ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = cell_type)) +
  geom_point() +
  theme_classic() 
```

After looking at the cell type distribution, the hemoglobin concentration makes sense as it corrspends to erythocytes which are high in hemoglobin.

### Add Batch Information

Preprocessed Seurat object's will often contain information about what batch the samples were processed in as well as how doublets were calculated. From the paper for this dataset, the batch information is found in a supplementary table and the authors claimed most doublets were classified in "Celltype" = "Uncategorized 1". Because they did not include the doublet information in the metadata, we will add it in this section. Doublet detection and removal is sensitive because you don't want to remove any valuable outliers but still take into consideration the noisiness of the data.

To define doublets, packages in both R and Python run algorithms per batch. This is why we imported the batch information so we could subset the larger object and filter out doublets per batch.

```{r}
# Make a data frame and extract barcode and Sample ID metadata from se obj
info <- data.frame(Barcode = colnames(se), "Sample ID" = se@meta.data$'Sample ID')
colnames(info) <- gsub("\\.", " ", colnames(info))

# Load in batch information
batch_info <- read.csv("../data/batch_info.csv")

# Rename batch_info column names to have a space instead of "."
colnames(batch_info) <- gsub("\\.", " ", colnames(batch_info))

batch_info <- batch_info %>%
  select("Sample ID", "Experimental batch")

head(batch_info)
```

```{r}
# merge the batch_info with the info dataframe
info <- merge(info, batch_info, by = "Sample ID")

rownames(info) <- info$Barcode
info <- info %>% select(-Barcode)

# Add batch numbers to the metadata
se <- AddMetaData(se, info)
```

### DoubletFinder

There are many different packages that can be used ot detect doublets. If you are familiar with Python, we use Scrublet most often. But for the sake of staying in one programming language, doubletFinder was found to be one of the most accurate R packages. DoubletFinder uses a nearest neighbor approach to identify doublets. The package has a function called "doubletFinder" that takes in a Seurat object and returns a Seurat object with doublet information in the metadata.

```{r}
library(DoubletFinder)
# Find doublets
exp_btch <- unique(se@meta.data$'Experimental batch')
class(exp_btch)
```

```{r}
process_batch <- function(batch) {
  batch_seurat_object <- subset(se, cells = which(se@meta.data$'Experimental batch' == batch))
  # seurat_object <- CreateSeuratObject(counts = your_data_object)
  batch_seurat_object <- batch_seurat_object %>%
    NormalizeData() %>%
    FindVariableFeatures() %>%
    ScaleData() %>%
    RunPCA() %>%
    FindNeighbors() %>%
    FindClusters() 
  # Seurat::ElbowPlot(batch_seurat_object, ndims = 30)
  # DimPlot(se, reduction="umap", group.by = "Experimental batch")
  
  sweep.res.list_sample <- paramSweep(batch_seurat_object, PCs = 1:20, sct = FALSE)
  sweep.stats_sample <- summarizeSweep(sweep.res.list_sample, GT = FALSE)
  bcmvn_sample <- find.pK(sweep.stats_sample)
  # Line plot to show the pK values for BCmetric. The highest BCmetric is where the most optimal pK value is.
  # ggplot(bcmvn_sample, aes(pK, BCmetric, group = 1))+
  #   geom_point() +
  #   geom_line()
  
  pK <- bcmvn_sample %>%
    filter(BCmetric == max(BCmetric)) %>%
    select(pK)
  pK <- as.numeric(as.character(pK[[1]]))
  
  annotations <- batch_seurat_object@meta.data$seurat_clusters
  # annotations <- se@meta.data$cell_type
  homotypic.prop <- modelHomotypic(annotations)           ## ex: annotations <- se@meta.data$ClusteringResults
  nExp_poi <- round(0.075*nrow(se@meta.data))  ## Assuming 7.5% doublet formation rate - tailor for your dataset
  nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
  
  batch_seurat_object <- doubletFinder(
    batch_seurat_object,
    PCs = 1:20,
    pN = 0.25,
    pK = pK,
    nExp = nExp_poi.adj,
    reuse.pANN = FALSE,
    sct = FALSE)

  # mt <- batch_seurat_object@meta.data[,c("")]
  # info <- data.frame(Barcode = colnames(batch_seurat_object), "Sample ID" = batch_seurat_object@meta.data$'Sample ID')
  # colnames(info) <- gsub("\\.", " ", colnames(info))
  # doublet_info <- c(batch_seurat_object@meta.data$'Doublet_Class',)
  
  # Add doublet information to larger seurat object here
  pANN <- colnames(batch_seurat_object@meta.data) %>% 
    keep(grepl('^pANN*', colnames(batch_seurat_object@meta.data)))
  DF_class <- colnames(batch_seurat_object@meta.data) %>% 
    keep(grepl('^DF.classifications*', colnames(batch_seurat_object@meta.data)))
  # Extract values "0.1", "0.1", and "1000"
  params <- gsub("^pANN_", "", pANN)  # Remove "pANN_"
  params <- strsplit(params, "_")[[1]]  # Split by "_"
  pN <- params[1]  # Extract "0.1"
  pK <- params[2]  # Extract "0.1"
  doublet_run <- params[3]  # Extract "1000"
  
  # Create new columns "pN", "pK", and "doublet_run"
  colnames(batch_seurat_object@meta.data)[colnames(batch_seurat_object@meta.data) == pANN] <- "pANN"
  colnames(batch_seurat_object@meta.data)[colnames(batch_seurat_object@meta.data) == DF_class] <- "DF_class"
  batch_seurat_object@meta.data$pN <- pN
  batch_seurat_object@meta.data$pK <- pK
  batch_seurat_object@meta.data$doublet_run <- doublet_run
  
  # Return DF of doublet information here
  df <- data.frame(
    Barcode = colnames(batch_seurat_object),
    batch = batch_seurat_object@meta.data$'Experimental batch', 
    pANN = batch_seurat_object@meta.data$'pANN', 
    DF_class = batch_seurat_object@meta.data$'DF_class',
    doublet_run = batch_seurat_object@meta.data$doublet_run,
    pK = batch_seurat_object@meta.data$pK,
    pN = batch_seurat_object@meta.data$pN
    )
  
  # Add metadata to main Seurat object
  # db <- bind_rows(processed_doublets)
  rownames(df) <- df$Barcode
  # df <- df %>% select(-Barcode)
  # se <- AddMetaData(
  #   object = se, 
  #   metadata = df
  # )

  return(df)
  
}

processed_doublets <- lapply(exp_btch, process_batch)

```

```{r}
# Add doublet information to the main seurat object
test <- bind_rows(processed_doublets)
rownames(test) <- test$Barcode
test <- test %>% select(-Barcode)
se <- AddMetaData(
    object = se, 
    metadata = test
  )
```

### Perform Preprocessing

```{r}
se <- se %>%
    NormalizeData(verbose = FALSE) %>%
    FindVariableFeatures(
        method = "vst",
        nfeatures = 3000,
        verbose = FALSE) %>%
    ScaleData(verbose = FALSE, features = VariableFeatures(.)) %>%
    RunPCA(verbose = FALSE) %>%
    RunUMAP(dims = 1:30, verbose = FALSE)
```

```{r, fig.height=5}
# Plot UMAP colored by batch
DimPlot(se, reduction = "umap", group.by = 'DF_class') +
  labs(title = "UMAP Plot Colored by Batch")

```

```{r, fig.height=5}
# Plot UMAP by pANN
FeaturePlot(se, reduction = "umap", features = "pANN") +
  labs(title = "UMAP Plot Colored by pANN")
# Plot UMAP by cell type
DimPlot(se, reduction = "umap", group.by = "cell_type") +
  labs(title = "UMAP Plot Colored by Cell Type")

# DimPlot(se, reduction = "umap", group.by = "Celltype") +
#   labs(title = "UMAP Plot Colored by Batch")
```

lapply loops return DFs with 3 columns. barcode, doublet score, and doublet classification. make sure last element is the one you want to keep. then pipe that into bindrows().

The DoubletFinder vignette includes sctransform pre-processing steps that can be used instead.

### pK Parameter

pK parameter = the proportion of cells that are doublets This metric determines the accuracy of the model. The higher the pK, the more stringent the model is in classifying doublets. The lower the pK, the more lenient the model is in classifying doublets. pN parameter = default number of doublets we expect to find K(?) = expected number of doublets

pANN = proportion of artificial nearest neighbors.

## Resave Seurat object

```{r}
saveRDS(se, '../data/workshop-data.rds')
```

### Session Info

```{r}
sessionInfo()
```
