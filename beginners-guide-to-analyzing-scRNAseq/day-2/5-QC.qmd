---
title: "5 - Quality Control"
format: html
editor: visual
author: Rose Hedderman
---

# Quality Control

## Introduction

### Information

### Key Takeaways

## Loading Libraries and Data

```{r, eval=FALSE}
if (!requireNamespace("tidyverse", quietly = TRUE))
    install.packages('tidyverse')
if (!requireNamespace("Seurat", quietly = TRUE))
    install.packages('Seurat')
# if (!requireNamespace("plotly", quietly = TRUE))
#     install.packages('plotly')
if (!requireNamespace("colorBlindness", quietly = TRUE))
    install.packages('colorBlindness')
# if (!requireNamespace("cluster", quietly = TRUE))
#     install.packages('cluster') # The cluster package provides tools to calculate clustering metrics, here used for silhouette analysis
if (!requireNamespace("RColorBrewer", quietly = TRUE))
    install.packages('RColorBrewer')
# if (!requireNamespace("scales", quietly = TRUE))
#     install.packages('scales')
# if (!requireNamespace("viridis", quietly = TRUE))
#     install.packages('viridis')
# if (!requireNamespace("ARBOL", quietly = TRUE))
#     devtools::install_github('jo-m-lab/ARBOL') # ARBOL is used to plot clusters.
# if (!requireNamespace("presto", quietly = TRUE))
#     devtools::install_github('immunogenomics/presto') # presto is used to speed up Wilcoxon tests for marker gene calculation in Seurat
# if (!requireNamespace("vegan", quietly = TRUE))
#     BiocManager::install('vegan') # vegan is a community ecological analysis package that provides many tools for dissimilarity, ordination, and diversity analysis, we will use it for diversity analysis here
# if (!requireNamespace("DT", quietly = TRUE))
#     install.packages('DT')
```

```{r}
suppressPackageStartupMessages({
  library(Seurat)
  library(tidyverse)
  library(RColorBrewer)
  library(colorBlindness)
  # library(ARBOL)
  # library(plotly)
  # library(scales)
  # library(viridis)
  # library(vegan)
  # library(cluster)
})
set.seed(687)
```

```{r}
se <- readRDS('../data/workshop-data.rds')
# Load a provided gene conversion table to convert ENSG to readable gene symbols
genes <- read_csv('../data/cov_flu_gene_names_table.csv') 

# Remake Seurat object
mtx <- se@assays$RNA@data
rownames(mtx) <- genes[match(row.names(mtx),genes$index), ]$feature_name

se <- CreateSeuratObject(counts = mtx, meta.data = se@meta.data)

se
```

```{r}
# rm(mtx)
# Set color palette
pal <- paletteMartin
names(pal) <- sort(unique(se$Celltype))
```

## Preprocessing

### Filter out the overexpressed genes

```{r}
# Look at the first 25 cells for a couple of genes to understand count matrix
mtx[c("CD3D", "TCL1A", "MS4A1"), 1:30]
```
### Add Batch Information

```{r}
# Make a data frame and extract barcode and Sample ID metadata from se obj
info <- data.frame(Barcode = colnames(se), "Sample ID" = se@meta.data$'Sample ID')
colnames(info) <- gsub("\\.", " ", colnames(info))

# Load in batch information
batch_info <- read.csv("../data/batch_info.csv")
# Rename batch_info column names to have a space instead of "."
colnames(batch_info) <- gsub("\\.", " ", colnames(batch_info))
batch_info <- batch_info %>%
  select("Sample ID", "Experimental batch")
# merge the batch_info with the info dataframe
info <- merge(info, batch_info, by = "Sample ID")

rownames(info) <- info$Barcode
info <- info %>% select(-Barcode)

# Add batch numbers to the metadata
se <- AddMetaData(se, info)
```

```{r}
# Find the metadata columns of interest
colnames(se@meta.data)
qc_metrics <- se@meta.data[,c('Percentage of mitochondrial gene', 'nFeature_RNA', 'nCount_RNA', 'Number of UMI', 'Number of Gene')]
head(qc_metrics)
```

```{r}
# Assume you have a Seurat object named se
gene_list <- rownames(se@assays$RNA@features)
# Search for genes that start with "RPS"
# genes_starting_with_MT <- grep("^MT-", gene_list, value = TRUE)
# # Print the genes starting with "RPS"
# print(genes_starting_with_MT)
se <- PercentageFeatureSet(se, pattern = "^MT-", col.name = "perc.mt")
se <- PercentageFeatureSet(se, pattern = "^RPS |^RPL", col.name = "perc.ribo")
se <- PercentageFeatureSet(se, pattern = "^HB[^(P)]", col.name = "perc.hb")
```

```{r}
se <- Seurat::NormalizeData(se, verbose = FALSE) %>%
  Seurat::FindVariableFeatures(selection.method = "vst", nfeatures = 3000, verbose = FALSE) %>%
  Seurat::ScaleData(verbose = FALSE) %>%
  Seurat::RunPCA(pc.genes = se@var.genes, npcs = 30, verbose = FALSE) %>%
  Seurat::RunUMAP(dims = 1:30, verbose = FALSE)
  
# Plot UMAP colored by batch
DimPlot(se, reduction = "umap", group.by = "Celltype") +
  labs(title = "UMAP Plot Colored by Batch")

```


```{r}
# Also compute the UMAP embedding
Seurat::ElbowPlot(se, ndims = 40)
```
```{r, fig.width=8, fig.height=6}}
# Plot counts
VlnPlot(se,
  group.by = "Sample ID",
  features = "nCount_RNA",
  pt.size = 0
  ) + NoLegend()
```

```{r}
# Plot counts
# Extract nCount_RNA values from the metadata
nCount_RNA_values <- se@meta.data$nCount_RNA
# Create a histogram of nCount_RNA values
hist(nCount_RNA_values, breaks = 1000,
  main = "Distribution of nCount_RNA Across Cells",
  xlim = c(0,30000),
  xlab = "nCount_RNA", ylab = "Frequency",
  col = "skyblue",
  plot = TRUE)
```

```{r, fig.width=8, fig.height=6}}
# Plot genes across samples
VlnPlot(se,
  group.by = "Sample ID",
  features = "nFeature_RNA",
  pt.size = 0,
  ) + NoLegend()
```

```{r, fig.width=8, fig.height=6}}
# QFM: How do I plot these all at the same time?
# Plot features
VlnPlot(se,
  group.by = "Sample ID",
  features = "perc.mt",
  # log = TRUE,
  pt.size = 0,
  ) + NoLegend()
```

```{r, fig.width=8, fig.height=6}}
# Plot features
VlnPlot(se,
  group.by = "Sample ID",
  features = "perc.ribo",
  # log = TRUE,
  pt.size = 0
  ) + NoLegend()
```

```{r, fig.width=8, fig.height=6}}
# Plot features
VlnPlot(se,
  group.by = "Sample ID",
  features = "perc.hb",
  # log = TRUE,
  pt.size = 0
  ) + NoLegend()
```

```{r}
# Plot features
VlnPlot(se,
  group.by = "Sample ID",
  features = c("perc.mt", "perc.ribo", "perc.hb"),
  # log = TRUE,
  pt.size = 0
  ) + NoLegend()
```

```{r}
# Marc's code
se@meta.data %>%
  ggplot2::ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.mt)) +
    ggplot2::geom_point() +
    ggplot2::theme_classic() +
    ggplot2::scale_color_gradient(low = "yellow", high = "red", limits = c(0, 20))
```

```{r}
# Calculate the feature covariance
se@meta.data %>%
  ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.ribo)) +
    geom_point() +
    theme_classic() +
    scale_color_gradient(low = "yellow", high = "red", limits = c(0, 50))
```

```{r}
# Calculate the feature covariance
se@meta.data %>%
  ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.hb)) +
  geom_point() +
  theme_classic() +
  scale_color_gradient(low = "yellow", high = "red", limits = c(0, 100))
```


### DoubletFinder

#### Find Doublets for one Sample ID 
```{r}
library(DoubletFinder)
# Find doublets
exp_btch <- unique(se@meta.data$'Experimental batch')
class(exp_btch)
```


```{r}

doublet_info <- list()
# batch = 1
process_batch <- function(batch) {
  batch_seurat_object <- subset(se, cells = which(se@meta.data$'Experimental batch' == batch))
  # seurat_object <- CreateSeuratObject(counts = your_data_object)
  batch_seurat_object <- batch_seurat_object %>%
    NormalizeData() %>%
    FindVariableFeatures() %>%
    ScaleData() %>%
    RunPCA() %>%
    FindNeighbors() %>%
    FindClusters() 
    # RunUMAP(., dims = 1:20)
  Seurat::ElbowPlot(batch_seurat_object, ndims = 30)
  DimPlot(se, reduction="umap", group.by = "Experimental batch")
  
  sweep.res.list_sample <- paramSweep(batch_seurat_object, PCs = 1:20, sct = FALSE)
  sweep.stats_sample <- summarizeSweep(sweep.res.list_sample, GT = FALSE)
  bcmvn_sample <- find.pK(sweep.stats_sample)
  # Line plot to show the pK values for BCmetric. The highest BCmetric is where the most optimal pK value is.
  ggplot(bcmvn_sample, aes(pK, BCmetric, group = 1))+
    geom_point() +
    geom_line()
  
  pK <- bcmvn_sample %>%
    filter(BCmetric == max(BCmetric)) %>%
    select(pK)
  pK <- as.numeric(as.character(pK[[1]]))
  
  annotations <- batch_seurat_object@meta.data$seurat_clusters
  # annotations <- se@meta.data$cell_type
  homotypic.prop <- modelHomotypic(annotations)           ## ex: annotations <- se@meta.data$ClusteringResults
  nExp_poi <- round(0.075*nrow(se@meta.data))  ## Assuming 7.5% doublet formation rate - tailor for your dataset
  nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
  
  batch_seurat_object <- doubletFinder(
    batch_seurat_object,
    PCs = 1:20,
    pN = 0.1,
    pK = pK,
    nExp = nExp_poi.adj,
    reuse.pANN = FALSE,
    sct = FALSE)

  mt <- batch_seurat_object@meta.data[,c("")]
  info <- data.frame(Barcode = colnames(batch_seurat_object), "Sample ID" = batch_seurat_object@meta.data$'Sample ID')
  colnames(info) <- gsub("\\.", " ", colnames(info))
  doublet_info <- c(batch_seurat_object@meta.data$'Doublet_Class',)
  
  # Add doublet information to larger seurat object here
  pANN <- colnames(batch_seurat_object@meta.data) %>% 
    keep(grepl('^pANN*', colnames(batch_seurat_object@meta.data)))
  DF_class <- colnames(batch_seurat_object@meta.data) %>% 
    keep(grepl('^DF.classifications*', colnames(batch_seurat_object@meta.data)))
  # Extract values "0.1", "0.1", and "1000"
  params <- gsub("^pANN_", "", pANN)  # Remove "pANN_"
  params <- strsplit(params, "_")[[1]]  # Split by "_"
  pN <- params[1]  # Extract "0.1"
  pK <- params[2]  # Extract "0.1"
  doublet_run <- params[3]  # Extract "1000"
  
  # Create new columns "pN", "pK", and "doublet_run"
  colnames(batch_seurat_object@meta.data)[colnames(batch_seurat_object@meta.data) == pANN] <- "pANN"
  colnames(batch_seurat_object@meta.data)[colnames(batch_seurat_object@meta.data) == DF_class] <- "DF_class"
  batch_seurat_object@meta.data$pN <- pN
  batch_seurat_object@meta.data$pK <- pK
  batch_seurat_object@meta.data$doublet_run <- doublet_run
  
  # Return DF of doublet information here
  df <- data.frame(
    Barcode = colnames(batch_seurat_object),
    batch_seurat_object@meta.data$'Experimental batch', 
    batch_seurat_object@meta.data$'pANN', 
    batch_seurat_object@meta.data$'DF_class',
    batch_seurat_object@meta.data$'doublet_run',
    batch_seurat_object@meta.data$pK,
    batch_seurat_object@meta.data$pN
    )
  return(df)
  
}

processed_doublets <- lapply(exp_btch, process_batch)

# Print renamed column
print(names(seurat_obj@meta.data))
# # Make a data frame and extract barcode and Sample ID metadata from se obj
# info <- data.frame(Barcode = colnames(se), "Sample ID" = se@meta.data$'Sample ID')
# colnames(info) <- gsub("\\.", " ", colnames(info))
# 
# # Load in batch information
# batch_info <- read.csv("../data/batch_info.csv")
# # Rename batch_info column names to have a space instead of "."
# colnames(batch_info) <- gsub("\\.", " ", colnames(batch_info))
# batch_info <- batch_info %>%
#   select("Sample ID", "Experimental batch")
# # merge the batch_info with the info dataframe
# info <- merge(info, batch_info, by = "Sample ID")
# 
# rownames(info) <- info$Barcode
# info <- info %>% select(-Barcode)
# 
# # Add batch numbers to the metadata
# se <- AddMetaData(se, info)

```

```{r}


```

```{r}
```

```{r}
values <- se_sample_1@meta.data$pANN_0.1_0.1_4180
# Plot
hist(values, breaks = 1000,
  main = "Distribution of pANN_0.1_0.1_3932 Across Cells",
  # xlim = c(0,1),
  xlab = "pANN_0.1_0.1_4180", ylab = "Frequency",
  col = "skyblue",
  plot = TRUE)

classifications <- data.frame(class = se_sample_1@meta.data$'DF.classifications_0.1_0.1_4180')
table(classifications)
# Plot the bar plot
ggplot(classifications, aes(x = class)) +
  geom_bar(fill = "blue", color = "black", alpha = 0.7) +
  labs(title = "Distribution of DF Classifications",
       x = "DF Classifications",
       y = "Frequency") +
  theme_minimal()
```

```{r, fig.height=5}
# Plot UMAP colored by batch
DimPlot(se_sample_1, reduction = "umap", group.by = "DF.classifications_0.1_0.1_4180") +
  labs(title = "UMAP Plot Colored by Batch")

```

```{r, fig.height=5}
# Plot UMAP by pANN
FeaturePlot(se_sample_1, reduction = "umap", features = "pANN_0.1_0.1_4180") +
  labs(title = "UMAP Plot Colored by pANN")
```

```{r}

# colnames(se)
cell_barcodes <- colnames(se)
batch_ids <- data.frame(bc = substr(cell_barcodes, 1, 3))
# batch_ids <- data.frame(bc = colnames(se))

class(batch_ids)

# classifications <- data.frame(class = se_sample@meta.data$'DF.classifications_0.25_0.16_3932')
# table(classifications)
# Plot the bar plot
ggplot(batch_ids, aes(x = bc)) +
  geom_bar(fill = "blue", color = "black", alpha = 0.7) +
  labs(title = "Distribution of  Batches",
       x = "Batches",
       y = "Frequency") +
  theme_minimal()
```

```{r}
```


lapply loops return DFs with 3 columns. barcode, doublet score, and doublet classification. make sure last element is the one you want to keep. then pipe that into bindrows(). 


```{r}
lapply(sample_id in sample_ids) {
    print(sample_id)
    # Subset the original Seurat object to include only the cells from the current sample
    sample_seurat_object <- subset(se, cells = which(se@meta.data$'Sample ID' == sample_id))
    
    # Perform doublet detection on the current sample using DoubletFinder or any other method
    # sample_id = "Flu 1"
    # sample_seurat_object <- subset(se, cells = which(se@meta.data$'Sample ID' == sample_id))
    # seurat_object <- CreateSeuratObject(counts = your_data_object)
    sample_seurat_object <- sample_seurat_object %>% 
      NormalizeData() %>%
      FindVariableFeatures() %>%
      ScaleData() %>% 
      RunPCA() %>% 
      FindNeighbors() %>% 
      FindClusters() %>% 
      RunUMAP(., dims = 1:20)
    
    sweep.res.list_sample <- paramSweep(sample_seurat_object, PCs = 1:20, sct = FALSE)
    sweep.stats_sample <- summarizeSweep(sweep.res.list_sample, GT = FALSE)
    bcmvn_sample <- find.pK(sweep.stats_sample)
    # Line plot to show the pK values for BCmetric. The highest BCmetric is where the most optimal pK value is.
    # ggplot(bcmvn_sample, aes(pK, BCmetric, group = 1))+
    #   geom_point() +
    #   geom_line()
    
    pK <- bcmvn_sample %>%
      filter(BCmetric == max(BCmetric)) %>%
      select(pK)
    pK <- as.numeric(as.character(pK[[1]]))
    
    annotations <- sample_seurat_object@meta.data$seurat_clusters
    homotypic.prop <- modelHomotypic(annotations)           
    nExp_poi <- round(0.075*nrow(se@meta.data))  ## Assuming 7.5% doublet formation rate - tailor for your dataset
    nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
    
    sample_seurat_object <- doubletFinder(
      sample_seurat_object,
      PCs = 1:20,
      pN = 0.25,
      pK = pK,
      nExp = nExp_poi.adj,
      reuse.pANN = FALSE,
      sct = FALSE)
    
    # Extract metadata from 'se1'
    metadata_to_add <- sample_seurat_object@meta.data[, c("pANN_0.25_0.22_4025", "^DF\\.classifications")]

    # Add metadata to 'se2' as new columns
    se2 <- AddMetaData(object = se2, metadata = metadata_to_add)
    
    # Optionally, you can add doublet information to the original Seurat object or perform any other operations
    
    # Delete the intermediary objects to minimize memory usage
    rm(sample_seurat_object)
}
```

#### Find Doublets for all Sample IDs

```{r}
```{r}
library("DoubletFinder")
# Find doublets
## Pre-process Seurat object with added steps from DoubletFinder vignette

## Here,  "seurat_clusters" are defined
se <- FindNeighbors(se, dims = 1:20)
se <- FindClusters(se, algorithm = 1) 
se <- RunUMAP(se, dims = 1:20)
```

The DoubletFinder vignette includes sctransform pre-processing steps that can be used instead.

### pK Parameter
pK parameter = the proportion of cells that are doublets
This metric determines the accuracy of the model. The higher the pK, the more stringent the model is in classifying doublets. The lower the pK, the more lenient the model is in classifying doublets.
pN parameter = default number of doublets we expect to find K(?) = expected number of doublets 

```{r}
## pK Identification (no ground-truth) ---------------------------------------------------------------------------------------
sweep.res.list_flu <- paramSweep(se, PCs = 1:10, sct = FALSE)
sweep.stats_flu <- summarizeSweep(sweep.res.list_flu, GT = FALSE)
bcmvn_flu <- find.pK(sweep.stats_flu)
# Line plot to show the pK values for BCmetric. The highest BCmetric is where the most optimal pK value is.
ggplot(bcmvn_flu, aes(pK, BCmetric, group = 1))+
  geom_point() +
  geom_line()
```

```{r}
pK <- bcmvn_flu %>%
  filter(BCmetric == max(BCmetric)) %>%
  select(pK)
pK <- as.numeric(as.character(pK[[1]]))
```

```{r}
## pK Identification (ground-truth) ------------------------------------------------------------------------------------------
# sweep.res.list_kidney <- paramSweep(se, PCs = 1:10, sct = FALSE)
# gt.calls <- se@meta.data[rownames(sweep.res.list_kidney[[1]]), "GT"].   ## GT is a vector containing "Singlet" and "Doublet" calls recorded using sample multiplexing classification and/or in silico geneotyping results
# sweep.stats_kidney <- summarizeSweep(sweep.res.list_kidney, GT = TRUE, GT.calls = gt.calls)
# bcmvn_kidney <- find.pK(sweep.stats_kidney)
```

```{r}
## Homotypic Doublet Proportion Estimate based on user-defined/metadata-found cell clusters -------------------------------------------------------------------------------------
annotations <- se@meta.data$seurat_clusters
# annotations <- se@meta.data$cell_type
homotypic.prop <- modelHomotypic(annotations)           ## ex: annotations <- se@meta.data$ClusteringResults
nExp_poi <- round(0.075*nrow(se@meta.data))  ## Assuming 7.5% doublet formation rate - tailor for your dataset
nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
```
pANN = proportion of artificial nearest neighbors.
```{r}
## Run DoubletFinder with varying classification stringencies ----------------------------------------------------------------
se_filtered <- doubletFinder(
  se,
  PCs = 1:10,
  pN = 0.25,
  pK = pK,
  nExp = nExp_poi.adj,
  reuse.pANN = FALSE,
  sct = FALSE)
# se <- doubletFinder(
#   se,
#   PCs = 1:10,
#   pN = 0.25,
#   pK = 0.09,
#   nExp = nExp_poi.adj,
#   reuse.pANN = "pANN_0.25_0.09_913",
#   sct = FALSE)
```

```{r}
DimPlot(se_filtered, reduction = 'umap', group.by = "DF.classification...")
DimPlot(se_filtered, reduction = 'umap', group.by = "DF.classifications_0.25_0.05-4468")
DimPlot(se_filtered, reduction = 'umap', group.by = 'DF.classifications_0.25_0.05_4468')
```

```{r}
# Plot counts
VlnPlot(se,
group.by = "Sample ID",
features = "nCount_RNA",
# log = TRUE,
ncol = 2,
pt.size = 0,
# y.max = 15000
) + NoLegend()
```

```{r}
# Plot counts
# Extract nCount_RNA values from the metadata
nCount_RNA_values <- se@meta.data$nCount_RNA
# Create a histogram of nCount_RNA values
hist(nCount_RNA_values, breaks = 1000,
main = "Distribution of nCount_RNA Across Cells",
xlim = c(0,30000),
xlab = "nCount_RNA", ylab = "Frequency",
col = "skyblue",
plot = TRUE)
```

```{r}
# Plot genes across samples
VlnPlot(se,
group.by = "Sample ID",
features = "nFeature_RNA",
pt.size = 0,
) + NoLegend()
```

```{r}
# QFM: How do I plot these all at the same time?
# Plot features
VlnPlot(se,
group.by = "Sample ID",
features = "perc.mt",
# log = TRUE,
pt.size = 0,
) + NoLegend()
# Plot features
VlnPlot(se,
group.by = "Sample ID",
features = "perc.ribo",
# log = TRUE,
pt.size = 0
) + NoLegend()
# Plot features
VlnPlot(se,
group.by = "Sample ID",
features = "perc.hb",
# log = TRUE,
pt.size = 0
) + NoLegend()
# Plot features
VlnPlot(se,
group.by = "Sample ID",
features = c("perc.mt", "perc.ribo", "perc.hb"),
# log = TRUE,
pt.size = 0
) + NoLegend()
se@meta.data %>%
ggplot2::ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.mt)) +
ggplot2::geom_point() +
ggplot2::theme_classic() +
ggplot2::scale_color_gradient(low = "yellow", high = "red")
# Calculate the feature covariance
se@meta.data %>%
ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.ribo)) +
geom_point() +
theme_classic() +
scale_color_gradient(low = "yellow", high = "red")
# Calculate the feature covariance
se@meta.data %>%
ggplot(., ggplot2::aes(x = nCount_RNA, y = nFeature_RNA, color = perc.hb)) +
geom_point() +
theme_classic() +
scale_color_gradient(low = "yellow", high = "red")
table(se_filtered@meta.data$DF.classifications_0.25_0.05_4468)
gc()
rm(se_filtered);gc
rm(se_filtered);gc()
# Plot counts
VlnPlot(se,
group.by = "Sample ID",
features = "nCount_RNA",
# log = TRUE,
ncol = 2,
pt.size = 0,
# y.max = 15000
) + NoLegend()
# Plot counts
VlnPlot(se,
group.by = "Sample ID",
features = "nCount_RNA",
# log = TRUE,
ncol = 2,
pt.size = 0,
# y.max = 15000
) + NoLegend()
# Assume you have a Seurat object named se
gene_list <- rownames(se@assays$RNA@features)
# Search for genes that start with "RPS"
genes_starting_with_RPS <- grep("^MT-", gene_list, value = TRUE)
# Print the genes starting with "RPS"
print(genes_starting_with_RPS)

```

### Session Info

```{r}
sessionInfo()
```
